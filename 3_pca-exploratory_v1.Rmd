---
title: "Section 3: PCA plots (exploratory analyses)"
date: "`r Sys.Date()`"
author:
  - name: Arun Seetharam
  - name: Ha Vu
    affiliation: Tuteja Lab
    affiliation_url: https://www.tutejalab.org
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: tango
---

```{r setup, include=FALSE}
options(max.print = "75")
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "assets/",
  fig.width = 8,
  prompt = FALSE,
  tidy = FALSE,
  message = FALSE,
  warning = TRUE
)
knitr::opts_knit$set(width = 75)
```

This section uses the count data (all datasets) generated in Section 1 for cluster analyses. Briefly, the count data are imported in R, batch corrected using `ComBat_seq`, `vst` transformation and clustering is performed using `DESeq2`, and results are visualized as PCA plots.



# Prerequisites

R packages required for this section are loaded.

```{r, warnings=TRUE, message=FALSE}
setwd("~/github/BAPvsTrophoblast_Amnion")
library(sva)
library(tidyverse)
library(DESeq2)
library(vsn)
library(pheatmap)
library(ggrepel)
library(RColorBrewer)
library(plotly)
library(PCAtools)
library(scales)
library(htmlwidgets)
library(factoextra)
library(spatstat.core)
library(cluster)
```


# PCA plots for all datasets

## Prepare datasets

The `counts` data and its associated metadata (`coldata`) are imported for analyses.

```{r dataset, warnings=TRUE, message=FALSE}
counts = 'assets/counts-pca-v2.txt'
groupFile = 'assets/batch-pca-v2.txt'
coldata <-
  read.csv(
    groupFile,
    row.names = 1,
    sep = "\t",
    stringsAsFactors = TRUE
  )
cts <- as.matrix(read.csv(counts, sep = "\t", row.names = "gene.ids"))
```

Inspect the `coldata`.

```{r coldata}
DT::datatable(coldata)
```

Reorder columns of `cts` according to `coldata` rows. Check if samples in both files match.

```{r order, warnings=TRUE, message=FALSE}
colnames(cts)
all(rownames(coldata) %in% colnames(cts))
cts <- cts[, rownames(coldata)]
```

### Batch correction

Using `Combat_seq` (SVA package) run batch correction - using bioproject IDs as variable (dataset origin).

```{r batchcorrect, warnings=TRUE, message=TRUE}
cov1 <- as.factor(coldata$authors)
adjusted_counts <- ComBat_seq(cts, batch = cov1, group = NULL)
all(rownames(coldata) %in% colnames(cts))
cts <- cts[, rownames(coldata)]
```

### run DESeq2

The batch corrected read counts are then used for running DESeq2 analyses.

```{r deseq2, warnings=TRUE, message=FALSE}
dds <- DESeqDataSetFromMatrix(countData = adjusted_counts,
                              colData = coldata,
                              design = ~ group)
```

### Transformation:
```{r vst, warnings=TRUE, message=FALSE}
vst <- assay(vst(dds))
p <- pca(vst, metadata = coldata, removeVar = 0.1) ##why is this needed?
vsd <- vst(dds, blind = FALSE)
pcaData <-
  plotPCA(vsd,
          intgroup = c("group", "authors"),
          returnData = TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
```



## PCA plot (all)

PCA plot for the dataset that includes all libraries.

```{r pcaFull_comp, warnings=TRUE, message=FALSE}
rv <- rowVars(assay(vsd))
select <-
  order(rv, decreasing = TRUE)[seq_len(min(500, length(rv)))]
pca <- prcomp(t(assay(vsd)[select, ]), center=TRUE, scale.=FALSE)
percentVar <- pca$sdev ^ 2 / sum(pca$sdev ^ 2)
intgroup = c("group", "authors")
intgroup.df <- as.data.frame(colData(vsd)[, intgroup, drop = FALSE])
group <- if (length(intgroup) > 1) {
  factor(apply(intgroup.df, 1, paste, collapse = " : "))
}
d <- data.frame(
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2],
  PC3 = pca$x[, 3],
  PC4 = pca$x[, 4],
  PC5 = pca$x[, 5],
  group = group,
  intgroup.df,
  name = colnames(vsd)
)
```

### Components 1 and 2

```{r pcaFull_C1-C2, fig.cap="Fig 3.1: PCA plots (all samples)", fig.width=8, fig.height=8}
g <- ggplot(d, aes(PC1, PC2, color = group.1, shape = authors)) +
  scale_shape_manual(values = 1:8) +
  theme_bw() +
  theme(legend.title = element_blank(), legend.position = "none") +
  geom_point(size = 2, stroke = 2) +
  xlab(paste("PC1", round(percentVar[1] * 100, 2), "% variance")) +
  ylab(paste("PC2", round(percentVar[2] * 100, 2), "% variance"))
ggplotly(g)
```

### Components 1 and 3
```{r pcaFull_C1-C3, fig.cap="Fig 3.1: PCA plots (all samples)", fig.width=8, fig.height=8}
g <- ggplot(d, aes(PC1, PC3, color = group.1, shape = authors)) +
  scale_shape_manual(values = 1:8) +
  theme_bw() +
  theme(legend.title = element_blank(), legend.position = "none") +
  geom_point(size = 2, stroke = 2) +
  xlab(paste("PC1", round(percentVar[1] * 100, 2), "% variance")) +
  ylab(paste("PC3", round(percentVar[3] * 100, 2), "% variance"))
ggplotly(g)
```

### Components 2 and 3
```{r pcaFull_C2-C3, fig.cap="Fig 3.1: PCA plots (all samples)", fig.width=8, fig.height=8}
g <- ggplot(d, aes(PC2, PC3, color = group.1, shape = authors)) +
  scale_shape_manual(values = 1:8) +
  theme_bw() +
  theme(legend.title = element_blank(), legend.position = "none") +
  geom_point(size = 2, stroke = 2) +
  xlab(paste("PC2", round(percentVar[2] * 100, 2), "% variance")) +
  ylab(paste("PC3", round(percentVar[3] * 100, 2), "% variance"))
ggplotly(g)
```


### Scree plot
```{r pcaFull_scree, fig.cap="Fig 3.1: PCA plots (all samples)", fig.width=8, fig.height=5}
scree_plot = data.frame(percentVar)
scree_plot[, 2] <- c(1:97)
colnames(scree_plot) <- c("variance", "component_number")
g <-
  ggplot(scree_plot, aes(component_number, variance * 100)) +
  geom_bar(stat = 'identity', fill = "slateblue") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(
      vjust = 1,
      hjust = 1,
      size = 12
    ),
    axis.text.y = element_text(size = 12),
    plot.margin = margin(10, 10, 10, 100),
    legend.position = "none",
    plot.title = element_text(color = "black", size = 18, face = "bold.italic"),
    axis.title.y = element_text(color = "black", size = 14, face = "bold"),
    axis.line.x = element_line(
      colour = 'black',
      size = 0.5,
      linetype = 'solid'
    ),
    axis.line.y = element_line(
      colour = 'black',
      size = 0.5,
      linetype = 'solid'
    ),
    axis.ticks.x = element_line(
      colour = 'black',
      size = 1,
      linetype = 'solid'
    ),
    axis.title.x = element_text(color = "black", size = 14, face = "bold")
  ) +
  xlab("Components") +
  ylab("Percent Variance") + ggtitle("All samples") +
scale_y_continuous(breaks = pretty_breaks())
ggplotly(g)
```


## Clustering Principal Components

### Method 1: K-Means

Using the first 3 components (PC1, PC2 and PC3) for clustering. Since the data has 41 different samples, the `k.max` is set to 41.

```{r pca1_recal,  warnings=TRUE, message=FALSE}
pca <- prcomp(t(assay(vsd)[select, ]), center=TRUE, scale.=FALSE, rank. = 3)
results <- pca$x
```

```{r pca1_cluster, fig.cap="Fig 3.1: Silhouette Statistic for finding optimal number of clusters", fig.width=8, fig.height=5}
fviz_nbclust(results, FUNcluster=kmeans, k.max = 41) 
```

```{r pca1_gap, fig.cap="Fig 3.1: Gap Statistic for finding optimal number of clusters", fig.width=8, fig.height=5}
fviz_nbclust(results, FUNcluster=kmeans, method="gap_stat", k.max = 41)
```


```{r pca1_eucdis, fig.cap="Fig 3.1: Euclidean distance for optimal clusters", fig.width=8, fig.height=5}
km1<-eclust(results, "kmeans", hc_metric="eucliden", k=4)
```
```{r pca1_eucdis2, fig.cap="Fig 3.1: Euclidean distance for optimal clusters", fig.width=8, fig.height=5}
km1<-eclust(results, "kmeans", hc_metric="eucliden", k=7)
```

```{r pca1_mandis, fig.cap="Fig 3.1: Manhattan distance for optimal clusters", fig.width=8, fig.height=5}
km2<-eclust(results, "kmeans", hc_metric="manhattan", k=4)
```

```{r pca1_mandis, fig.cap="Fig 3.1: Manhattan distance for optimal clusters", fig.width=8, fig.height=5}
km2<-eclust(results, "kmeans", hc_metric="manhattan", k=7)
```

```{r pca1_shilstatE, fig.cap="Fig 3.1: Silhouette Statistic (Euclidean)", fig.width=8, fig.height=5}
fviz_silhouette(km1) 
```
```{r pca1_shilstatM, fig.cap="Fig 3.1: Silhouette Statistic (Manhattan)", fig.width=14, fig.height=12}
pca <- prcomp(t(assay(vsd)[select, ]), center=TRUE, scale.=FALSE, rank. = 3)
results <- pca$x
distance <- get_dist(results, method = "euclidean")
fviz_dist(distance, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
```

### Method 2: Partitioning Around Medoids (PAM)


```{r pca1_pam1, fig.cap="Fig 3.1: Silhouette Statistic for finding optimal number of clusters", fig.width=8, fig.height=5}
fviz_nbclust(results, FUNcluster=cluster::pam, k.max = 41) 
```

```{r pca1_gap, fig.cap="Fig 3.1: Gap Statistic for finding optimal number of clusters", fig.width=8, fig.height=5}
fviz_nbclust(results, FUNcluster=cluster::pam, method="gap_stat", k.max = 41)
```


```{r pca1_eucdis, fig.cap="Fig 3.1: Euclidean distance for optimal clusters", fig.width=8, fig.height=5}
pam1<-eclust(results, "pam", k=5) 
```

```{r pca1_mandis, fig.cap="Fig 3.1: Manhattan distance for optimal clusters", fig.width=8, fig.height=5}
fviz_silhouette(pam1)
```


### Method 3: Hierarchical Clustering

```{r pca1_hc1, fig.cap="Fig 3.1: Euclidean distance for optimal clusters", fig.width=8, fig.height=5}
dm<-dist(results) 
hc<-hclust(dm, method="complete") # simple dendrogram
plot(hc, hang=-1) 
rect.hclust(hc, k=7, border="red") 
clust.vec.5<-cutree(hc, k=7) 
```

```{r pca1_hc1, fig.cap="Fig 3.1: Euclidean distance for optimal clusters", fig.width=8, fig.height=5}
plot(density(dm))
```


```{r pca1_hc1, fig.cap="Fig 3.1: Euclidean distance for optimal clusters", fig.width=8, fig.height=5}
fviz_cluster(list(data=results, cluster=clust.vec.5))
```


```{r pca1_hc1, fig.cap="Fig 3.1: Euclidean distance for optimal clusters", fig.width=8, fig.height=5}
plot(silhouette(clust.vec.5, dm))
```
## PCA plot for diifferentiated cell libraries (no amnion datasets)

### Import datasets

The `counts` data and its associated metadata (`coldata`) are imported for analyses.

```{r import2, warnings=TRUE, message=FALSE}
setwd("~/github/BAPvsTrophoblast_Amnion")
counts2 = 'assets/counts-pca-v2.2.txt'
groupFile = 'assets/batch-pca-v2.2.txt'
coldata2 <-
  read.csv(
    groupFile,
    row.names = 1,
    sep = "\t",
    stringsAsFactors = TRUE
  )
cts2 <-
  as.matrix(read.csv(counts2, sep = "\t", row.names = "gene.ids"))
```

Inspect the `coldata`.

```{r coldata2}
DT::datatable(coldata2)
```

Reorder columns of `cts` according to `coldata` rows. Check if samples in both files match.
```{r order2}
all(rownames(coldata2) %in% colnames(cts2))
cts2 <- cts2[, rownames(coldata2)]
```

### Batch correction
Using `ComBat_seq` (SVA package) run batch correction - using bioproject IDs as variable (dataset origin).

```{r batchcorrect2, warnings=TRUE, message=TRUE}
cov1 <- as.factor(coldata2$authors)
adjusted_counts <- ComBat_seq(cts2, batch = cov1, group = NULL)
all(rownames(coldata2) %in% colnames(cts2))
cts2 <- cts2[, rownames(coldata2)]
```

### Run DESeq2
The batch corrected read counts are then used for running DESeq2 analyses.

```{r deseq2b, warnings=TRUE, message=FALSE}
dds <- DESeqDataSetFromMatrix(countData = adjusted_counts,
                              colData = coldata2,
                              design = ~ group)
```

### Transformation:

```{r vst2, warnings=TRUE, message=FALSE}
vsd <- vst(dds, blind = FALSE)
pcaData <-
  plotPCA(vsd,
          intgroup = c("group", "authors"),
          returnData = TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
```

## PCA plot (differenticated)

```{r pcaDif_comp, warnings=TRUE, message=FALSE}
rv <- rowVars(assay(vsd))
select <-
  order(rv, decreasing = TRUE)[seq_len(min(500, length(rv)))]
pca <- prcomp(t(assay(vsd)[select,]))
percentVar <- pca$sdev ^ 2 / sum(pca$sdev ^ 2)
intgroup = c("group", "authors")
intgroup.df <- as.data.frame(colData(vsd)[, intgroup, drop = FALSE])
group <- if (length(intgroup) > 1) {
  factor(apply(intgroup.df, 1, paste, collapse = " : "))
}
d <- data.frame(
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2],
  PC3 = pca$x[, 3],
  PC4 = pca$x[, 4],
  PC5 = pca$x[, 5],
  group = group,
  intgroup.df,
  name = colnames(vsd)
)
```

### Components 1 and 2

```{r pcaDif_C1-C2, fig.cap="Fig 3.1: PCA plots (all samples)", fig.width=8, fig.height=8}
g <- ggplot(d, aes(PC1, PC2, color = group.1, shape = authors)) +
  scale_shape_manual(values = 1:8) +
  theme_bw() +
  theme(legend.title = element_blank()) +
  geom_point(size = 2, stroke = 2) +
  xlab(paste("PC1", round(percentVar[1] * 100, 2), "% variance")) +
  ylab(paste("PC2", round(percentVar[2] * 100, 2), "% variance"))
ggplotly(g)
```

### Components 1 and 3
```{r pcaDif_C1-C3, fig.cap="Fig 3.1: PCA plots (all samples)", fig.width=8, fig.height=8}
g <- ggplot(d, aes(PC1, PC3, color = group.1, shape = authors)) +
  scale_shape_manual(values = 1:8) +
  theme_bw() +
  theme(legend.title = element_blank()) +
  geom_point(size = 2, stroke = 2) +
  xlab(paste("PC1", round(percentVar[1] * 100, 2), "% variance")) +
  ylab(paste("PC3", round(percentVar[3] * 100, 2), "% variance"))
ggplotly(g)
```

### Components 2 and 3
```{r pcaDif_C2-C3, fig.cap="Fig 3.1: PCA plots (all samples)", fig.width=8, fig.height=8}
g <- ggplot(d, aes(PC2, PC3, color = group.1, shape = authors)) +
  scale_shape_manual(values = 1:8) +
  theme_bw() +
  theme(legend.title = element_blank()) +
  geom_point(size = 2, stroke = 2) +
  xlab(paste("PC2", round(percentVar[2] * 100, 2), "% variance")) +
  ylab(paste("PC3", round(percentVar[3] * 100, 2), "% variance"))
ggplotly(g)
```


### Scree plot
```{r pcaDif_scree, fig.cap="Fig 3.1: PCA plots (all samples)", fig.width=8, fig.height=8}
scree_plot = data.frame(percentVar)
end = length(scree_plot$percentVar)
scree_plot[, 2] <- c(1:end)
colnames(scree_plot) <- c("variance", "component_number")


g <- ggplot(scree_plot, aes(component_number, variance * 100)) +
  geom_bar(stat = 'identity', fill = "slateblue") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(
      vjust = 1,
      hjust = 1,
      size = 12
    ),
    axis.text.y = element_text(size = 12),
    plot.margin = margin(10, 10, 10, 100),
    legend.position = "none",
    plot.title = element_text(color = "black", size = 18, face = "bold.italic"),
    axis.title.y = element_text(color = "black", size = 14, face = "bold"),
    axis.line.x = element_line(
      colour = 'black',
      size = 0.5,
      linetype = 'solid'
    ),
    axis.line.y = element_line(
      colour = 'black',
      size = 0.5,
      linetype = 'solid'
    ),
    axis.ticks.x = element_line(
      colour = 'black',
      size = 1,
      linetype = 'solid'
    ),
    axis.title.x = element_text(color = "black", size = 14, face = "bold")
  ) +
  xlab("Components") +
  ylab("Percent Variance") + ggtitle("Differntiated samples")
scale_y_continuous(expand = expansion(mult = c(0, .1)), breaks = pretty_breaks())
ggplotly(g)
```

### Interactive 3D PCA plot

```{r pcaDif_3D, warnings=TRUE, message=FALSE}
g <- plotPCA3D(vsd, intgroup = c("group", "authors"))
saveWidget(g, file = "interactive/PCA_dif.html")
```
[Interactive 3D PCA plot for diifferentiated samples](interactive/PCA_dif.html){target="_blank"}


## Session Information

```{r sessioninfo}
sessionInfo()
```
